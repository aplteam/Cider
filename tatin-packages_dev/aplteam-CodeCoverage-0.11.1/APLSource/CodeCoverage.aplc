:Class CodeCoverage
⍝ # The class `CodeCoverage`
⍝ This class provides methods to watch certain parts of the workspace being executed, presumably as part of running
⍝ a test framework such as [`Tester2`](https://github.com/aplteam/Tester2 "Link to Tester2 on GitHub"), although checking
⍝ code coverage by simply running an application can also be useful, especially for legacy code.\\
⍝ To do this, the following steps need to be performed:
⍝ ## Prepare
⍝ * Instantiate `CodeCoverage` and pass a comma-separated list of namespaces and/or classes to monitor as an argument
⍝   to `⎕NEW`.
⍝ * You may want to set the following two properties to customize `CodeCoverage` to your needs:
⍝   * `ignore`: comma-separated list of fully qualified names of functions, operators, namespaces and scripts to
⍝      ignore.
⍝   * `filename`: name used for three different files:
⍝     * To save the `⎕PROFILE` data in a component file with the extension `.profile`
⍝     * To save the canonical representations of the code in a component file with the extension `.cr`
⍝     * To save the HTML report with the `.html` extension\\
⍝     The collected data and the list of namespaces/classes to watch can be referenced as `data` and
⍝     `watch` but _not_ set: they are read-only instance properties.\\
⍝ ## Running the code
⍝ You must call the `Start` method before executing any code that is to be watched for coverage. Assuming that
⍝ the instance has been assigned to `C`, call `C.Start ⍬`.\\
⍝ Once all the code you are interested in has been executed call `C.Stop ⍬`.\\
⍝ When the test framework is finished, run `C.Finalise ⍬`.\\
⍝ **Notes:**
⍝ * You can stop and restart again as many times as you like. This can be useful to avoid `⎕PROFILE` collecting
⍝   data while a test framework is running rather than the application you are interested in: `⎕PROFILE` is expensive!
⍝ * You can run the test framework again, say on a different platform: if the `filename` property points to an already
⍝   existing component file, additional data is added by appending more components.
⍝ * The first component self-documents such a DCF file.\\
⍝ ## Generating a report
⍝ To create a meaningful report, call the shared method `CodeCoverage.ProcessDataAndCreateReport` and
⍝ pass `C.filename` (or a character vector containing the filename) as the right argument.\\
⍝ This method will aggregate the data, massage it, process it and finally create an HTML report from it.\\
⍝ Note that by default the report is not verbose, i.e. only the (fully qualified) names of all functions
⍝ and operators that were not executed at all and all the names of functions and operators that were only partially
⍝ executed are reported together with the lines not executed and the total number of lines.\\
⍝ This is a good place to start. Usually this leads to extending the list of things to ignore, adding more
⍝ test cases, deleting blocks of code that have become obsolete etc.\\
⍝ At one point, however, one might want the full details: to do this, add a 1 as the left argument when calling
⍝ `CodeCoverage.ProcessDataAndCreateReport`. The canonical representations of all functions and operators that are
⍝ only partially covered will become part of the report. The lines that weren't executed are highlighted (bold) and have
⍝ a right-pointing arrow on the left.\\
⍝ You may also create just a summary report by calling `ProcessDataAndCreateSummary`.\\
⍝ ## Limitations and flaws
⍝ * Nested namespaces/classes are currently not processed. This restriction may be lifted in a future release.
⍝ * Named dfns kept local within a traditional function are not processed correctly. This is a consequence of a
⍝   flaw in `⎕PROFILE`. This cannot be overcome without changing `⎕PROFILE`.\\
⍝ Home page: <https://github.com/aplteam/CodeCoverage>\\
⍝ Kai Jaeger

    ⎕IO←1 ⋄ ⎕ML←1

    :Field Public Shared Info←''             ⍝ Strictly speaking this should not be shared, but then CodeCoverage should not run in multiple instances anyway

    ∇ r←Version
      :Access Public Shared
    ⍝ Returns the version number from `TatinVars` if possible.
    ⍝ See also `History`
      :If 0<##.⎕NC'TatinVars.CONFIG'
          r←(⎕JSON⍠('Dialect' 'JSON5')⊢##.TatinVars.CONFIG).version
      :Else
    ⍝ When a script was not loaded with Tatin, there will be no namespace `TatinVars`.
    ⍝ In such cases we cannot provide a version number, so we return just ''.
          r←''
      :EndIf
    ∇

    ∇ History
      :Access Public Shared
    ⍝ * 0.11.1 from 2025-06-04
    ⍝   * When a reference to a namespace or class was passed as argument to `⎕NEW`, `CoderCoverage` reported zero code coverage.
    ⍝ * 0.11.0 from 2025-06-03
    ⍝   * New method `ProcessDataAndCreateSummary` introduced
    ⍝   * Several tests added
    ⍝ * 0.10.7 from 2024-06-05
    ⍝   * Bug fixes
    ⍝     * A comma-separated list as argument to ⎕NEW caused a LENGTH ERROR
    ⍝     * CodeCoverage tests attempted to act on itself - that cannot work properly because the tests overwrite ⎕PROFILE
    ⍝ * 0.10.6 from 2024-01-30
    ⍝   * Neither `#` nor `⎕SE` were allowed
    ⍝ * 0.10.5 from 2024-01-12
    ⍝   * Link to `Tester2` in the documentation corrected
    ⍝ * 0.10.4 from 2024-01-12
    ⍝   * Packages updated
    ⍝ * 0.10.3 from 2023-04-23
    ⍝   * Bug fix: Instance names could not be assigned to "ignore"
    ⍝ * 0.10.2 from 2023-04-09
    ⍝   * On non-Windows platforms the file access matrix needs setting to avoid problems
    ⍝ * 0.10.1 from 2023-04-08
    ⍝   The `CreateListingForFnsAndOpr` function deleted the "*.cr" file when it should not have
    ⍝ * 0.10.0 from 2023-03-23
    ⍝   * New function `DeleteFiles` added for getting rid of the two reporting files create/used by `CodeCoverage`, and
    ⍝     optionally also of the HML file
    ⍝   * Bug fix: ∆STOPPED caused a VALUE ERROR nothing wa actually executed
    ∇

    :Field Public Shared Readonly APL_Chars←'ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyzÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïðñòóôõöøùúûüþ0123456789∆⍙',⎕ucs (80=⎕dr' ')/9397+⍳26

    ∇ make1(watch_)
      :Access Public Instance
      :Implements Constructor
      :Access Public
      _ignore←''
      :If ~(⊃watch_)∊'#⎕'
      :AndIf 0<≢1↓⎕RSI
      :AndIf 0<(⊃1↓⎕RSI).⎕NC watch_
          watch_←(⊃1↓⎕NSI),'.',watch_
      :EndIf
      ⎕SIGNAL/{0∧.≠⍵:''⍬ ⋄ ('Not found: ',watch_)6}⎕NC watch_
      watch←'⎕se'⎕R'⎕SE'⍠('IC' 1)⊣watch_
      _filename←(739⌶0),'/CodeCoverage-',' '~⍨⍕⎕TS
      _data←0 2⍴''
      ∆STOPPED←0
    ∇

    ∇ Close
      :Implements destructor
      ⎕PROFILE'clear'
    ∇

    :Property data
    ⍝ Matrix with two columns and as many rows as there are observations collected by `⎕PROFILE`.\\
    :Access Public Instance
        ∇ r←Get
          r←_data
        ∇
    :EndProperty

    :Property ignore
    ⍝ Either empty or a comma-separated list of fully qualified function, operator class and namespace names
    ⍝ that should be ignored when compiling the coverage report.\\
    ⍝ Note that in case it is an ordinary namespace this means that all objects in that namespace will be ignored,
    ⍝ including any sub-namespaces.
    :Access Public Instance
        ∇ r←Get
          r←','(≠⊆⊢),_ignore
        ∇
        ∇ set value;v;noOf
          :If 0=noOf←+/∧\1=≡¨value.NewValue
              v←∊value.NewValue
          :Else
              v←(⊃{⍺,',',⍵}/noOf↑value.NewValue),noOf↓value.NewValue
          :EndIf
          'Must be character vector'⎕SIGNAL 11/⍨' '≠1↑0⍴v
          ('Has invalid characters',b/v)⎕SIGNAL 11/⍨∨/b←~v∊APL_Chars,',⎕#.'
          _ignore←v
        ∇
    :EndProperty

    :Property watch
    ⍝ A comma-separated list of namespaces and/or classes that are going to be watched for coverage,
    :Access Public Instance
        ∇ r←Get
          r←_watch
        ∇
        ∇ set value;v;b;v2
          v←∊value.NewValue
          'Must be character vector'⎕SIGNAL 11/⍨' '≠1↑0⍴v
          ('Has invalid characters',b/v)⎕SIGNAL 11/⍨∨/b←~v∊APL_Chars,',⎕#.'
          v2←','(≠⊆⊢),v
          v2←{(,'#')≡,⍵:⍵ ⋄ '⎕SE'≡⍵:⍵ ⋄ ~9.1 9.2∊⍨⎕NC⊂⍵:⍵ ⋄ ⍵≡ref←⍎⍵:w ⋄ ⍕ref}¨v2 ⍝ Convert any refs to their targets
          :If ~∧/v2∊,¨'#' '⎕SE'
              :If ∨/~b←0<⎕NC↑v2
                  11 ⎕SIGNAL⍨'Unknown names: ',⊃{⍺,',',⍵}/(~b)/v2
              :EndIf
          :EndIf
          _watch←v2
        ∇
    :EndProperty

    :Property filename
    :Access Public Instance
    ⍝ By default `filename` is a temporary file. However, you can specify your own filename here, with or without
    ⍝ an extension.\\
    ⍝ Note that this name will also be used to create the HTML file, just with a different extension.
        ∇ r←get
          r←_filename
        ∇
        ∇ set value;v
          v←value.NewValue
          'Invalid depth'⎕SIGNAL 11/⍨~(≡v)∊0 1
          'Must be a character vector'⎕SIGNAL 11/⍨' '≠1↑0⍴∊v
          _filename←⊃,/2↑⎕NPARTS v
        ∇
    :EndProperty

    ∇ {r}←{htmlFile}DeleteFiles filename
    ⍝ Delete both files created by `CodeCoverage` with the extensions `.profile` and `.cr`.\\
    ⍝ `filename` must be a single filename with path but without extension.\\
    ⍝ `htmlFile` defaults to 0, meaning that `filename` with an extension `.html` will not be deleted.
    ⍝ By specifying a 1 as left argument you can enforce it to be deleted.\\
    ⍝ `R` is an integer with the number of files deleted.
      :Access Public Shared
      'Right argument must be a simple character vector'Assert(≡filename)∊0 1
      'Right argument must be a simple character vector'Assert' '=1↑0⍴filename
      'You MUST not specify a file extension'Assert~'.'∊3⊃⎕NPARTS filename
      r←0
      htmlFile←{0<⎕NC ⍵:⍎⍵ ⋄ 0}'htmlFile'
      'The optional left argument must be 0 (default) or 1'Assert(⊂htmlFile)∊0 1
      :If IsFile filename,'.profile'
          r+←⎕NDELETE filename,'.profile'
      :EndIf
      :If IsFile filename,'.cr'
          r+←⎕NDELETE filename,'.cr'
      :EndIf
      :If htmlFile
      :AndIf IsFile filename,'.html'
          r+←⎕NDELETE filename,'.html'
      :EndIf
    ∇

    ∇ mdFilename←ProcessDataAndCreateSummary filename;dcfFilename
    ⍝ Compiles a summary file that can be used as a job in a GitHub workflow
      :Access Public Shared
      dcfFilename←(⊃,/2↑⎕NPARTS filename),'.profile'
      'File not found'⎕SIGNAL 11/⍨0=⎕NEXISTS dcfFilename
      {}ProcessData dcfFilename
      mdFilename←CreateSummary filename
    ∇

    ∇ filename←CreateSummary filename;dcfFilename;tno;watched;data;runs;md;tally;caption;table
      ⍝ This function creates an md file containing a summary of the coverage report from the data collected during the execution of an application.\\
      ⍝ You must call `ProcessData` first: this function relies on the data being aggregated.\\
      :Access Public Shared
      dcfFilename←(⊃,/2↑⎕NPARTS filename),'.profile'
      'File not found'⎕SIGNAL 11/⍨0=⎕NEXISTS dcfFilename
      tno←dcfFilename ⎕FSTIE 0
      watched←⎕FREAD tno 2
      data←⎕FREAD tno 10
      runs←⎕FREAD tno 4
      ⎕FUNTIE tno
      md←⊂'# Coverage Summary'
      md,←,⊂''
      :If 0=≢data
          md,←⊂'Nothing to report at all'
      :Else
          tally←≢data[;4]
          caption←⊃,/{⍺,', ',⍵}/watched
          md,←⊂'Watched: ',(⍕tally),' fns/opr within `',caption,'`'
          md,←⊂''
          :If 1=≢runs
              md,←⊂'The test suite was executed once:'
          :Else
              md,←⊂'The test suite was executed ',(⍕≢runs),' times:'
          :EndIf
          md,←⊂''
          table←('Executed at' 'APLVersion' 'Memory (MB)'),[0.5]⊂'---'
          md,←{,/('|',¨⍵),'|'}table⍪runs
          :If 0<≢∊data[;2 4]
              md,←⊂''
              md,←⊂'Overall ',(⍕⌊0.5+100×÷/+⌿≢¨data[;2 4]),'% of the testable code is covered.'
              md,←⊂''
              md,←⊂'(Comment lines, empty lines, all `:End`* lines etc. are ignored)'
          :EndIf
          md,←⊂''
          md,←⊂(⍕data[;3]+.=100),' of the fns/opr are 100% covered.'
      :EndIf
      filename←(⊃,/2↑⎕NPARTS filename),'.md'
      (⊂md)⎕NPUT filename 1
    ∇

    ∇ htmlFilename←{verbose}ProcessDataAndCreateReport filename;details;watch;dcfFilename
     ⍝ Takes the name of a component file created by first instantiating `CodeCoverage` and then calling
     ⍝ the instance methods `Start`, `Stop` and `Finalise`.\\
     ⍝ The components containing the `⎕PROFILE` data (11 and running) are then read, aggregated, massaged and
     ⍝ finally stored in the tenth component.\\
     ⍝ A report is then generated from the aggregated data and saved on disk.
     ⍝ `filename` is used for both, identifying the DCF file and the HTML, only the extensions are different.\\
     ⍝ The optional left argument `verbose` defaults to 0, which means that the code of the functions and operators
     ⍝ that are only partially covered will to be listed.\\
     ⍝ However, by specifying a 1 as left argument you can force the canonical representations of these functions
     ⍝ and operators to become part of the report with any lines that were not executed highlighted.\\
     ⍝ Note that this function can be called more than once on the same component file. It just wastes some resources
     ⍝ calculating the result again, which is not necessary. However, as long as the number of functions and operators
     ⍝ is not very large that does not matter much. If it does matter then call `ProcessData` and `CreateReport` instead:
     ⍝ that is all this function does anyway.
      :Access Public Shared
      dcfFilename←(⊃,/2↑⎕NPARTS filename),'.profile'
      'File not found'⎕SIGNAL 11/⍨0=⎕NEXISTS dcfFilename
      verbose←{0=⎕NC ⍵:0 ⋄ ⍎⍵}'verbose'
      {}ProcessData dcfFilename
      htmlFilename←verbose CreateReport filename
    ∇

    ∇ filename←{verbose}CreateReport filename;html;tally;caption;b;buff2;linkAndName;buff3;dcfFilename;tno;watched;data;watch;ignore;align;runs;buff
    ⍝ This function creates an HTML file containing a coverage report from the data collected during the execution of an application.\\
    ⍝ You must call `ProcessData` first: this function relies on the data being aggregated.\\
    ⍝ If the file extension of `filename` is not ".html" this will be enforced.\\
    ⍝ The optional ⍺ (`verbose`) defaults to 0, meaning that no code listings are part of the report.
      :Access Public Shared
      dcfFilename←(⊃,/2↑⎕NPARTS filename),'.profile'
      'File not found'⎕SIGNAL 11/⍨0=⎕NEXISTS dcfFilename
      tno←dcfFilename ⎕FSTIE 0
      watched←⎕FREAD tno,2
      data←⎕FREAD tno 10
      watch←⎕FREAD tno 2
      ignore←⎕FREAD tno 3
      runs←⎕FREAD tno 4
      ⎕FUNTIE tno
      verbose←{0<⎕NC ⍵:⍎⍵ ⋄ 0}'verbose'
      html←''
      html,←⊂'<!DOCTYPE html>'
      html,←⊂'<html lang="en">'
      html,←⊂'<head>'
      html,←⊂'<title>Coverage</title>'
      html,←⊂'<meta charset="utf-8"/>'
      html,←⊂'<style>'
      html,←GetScreenCss
      html,←GetPrintCss
      html,←⊂'</style>'
      ⍝ Download package with all needed components from DataTables CDN
      html,←⊂'<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/v/dt/jq-3.6.0/dt-1.11.2/b-2.0.0/b-print-2.0.0/fh-3.1.9/r-2.2.9/datatables.min.css"/>'
      html,←⊂'<script type="text/javascript" src="https://cdn.datatables.net/v/dt/jq-3.6.0/dt-1.11.2/b-2.0.0/b-print-2.0.0/fh-3.1.9/r-2.2.9/datatables.min.js"></script>'
      html,←⊂'</head>'
      html,←⊂'<body>'
      html,←⊂'<h1 id="top">Coverage Report</h1>'
      :If 0<≢Info
          html,←⊂'<p class="info">',(ExchangeHtmlSpecialChars Info),'</p>'
      :EndIf
      :If 0=≢data
          html,←⊂'<p>Nothing to report at all</p>'
      :Else
          tally←≢data[;4]
          caption←⊃,/{⍺,', ',⍵}/watched
          html,←⊂'<p>Watched: ',(⍕tally),' fns/opr within <code>',caption,'</code></p>'
          :If 1=≢runs
              html,←⊂'<p>The test suite was executed once:</p>'
          :Else
              html,←⊂'<p>The test suite was executed ',(⍕≢runs),' times:</p>'
          :EndIf
          html,←⊂'<table>'
          html,←⊂'<thead>'
          html,←⊂{'<tr>',(⊃,/{'<th>',⍵,'</th>'}¨⍵),'</tr>'}'Executed at' 'APLVersion' 'Memory (MB)'
          html,←⊂'</thead>'
          html,←⊂'<tbody>'
          html,←{'<tr>',(⊃,/{'<td>',⍵,'</td>'}¨⍵),'</tr>'}¨↓runs
          html,←⊂'</tbody>'
          html,←⊂'</table>'
          :If 0<≢∊data[;2 4]
              html,←⊂'<p>Overall ',(⍕⌊0.5+100×÷/+⌿≢¨data[;2 4]),'% of the testable code is covered.</p>'
              html,←⊂'<p>(Comment lines, empty lines, all <code>:End</code>* lines etc. are ignored)</p>'
          :EndIf
          html,←⊂'<p>',(⍕data[;3]+.=100),' of the fns/opr are 100% covered.</p>'
          b←~data[;3]∊0 100
          data←{⍵[⍋⍵[;3];]}data
          html,←⊂'<div id="partly-covered" class="keep-together">'
          html,←⊂'<table id="percent">'
          html,←⊂'<thead>'
          align←'left' 'left' 'left' 'right'
          html,←⊂{'<tr>',⍵,'</tr>'}⊃,/align{'<th style="text-align:',⍺,';">',⍵,'</th>'}¨'Function/Operator' 'Lines not executed' 'Coverage' '≢'
          html,←⊂'</thead>'
          html,←⊂'<tbody>'
          :If 0<≢buff←((≢data),3)⍴0
              data[;2]←data[;4]~¨data[;2]   ⍝ From "executed" to "not executed"
              buff[;1]←{4>≢⍵:{0=≢⍵:⍵ ⋄ ⊃{⍺,', ',⍵}/⍵}⍕¨⍵ ⋄ (⍕≢⍵),'←≢',Shorten ⍵}¨data[;2]
              buff[;2]←data[;3]
              buff[;3]←⍕∘≢¨data[;4]
              :If verbose
                  linkAndName←data[;1]{'<a href="#listing_',⍵,'" title="Link to listing">',⍺,'</a>'}∘⍕¨⍳≢data
                  buff3←linkAndName{'<td>',⍺,'</td><td>',(1⊃⍵),'</td><td>',(⍕2⊃⍵),'</td><td>',(3⊃⍵),'</td>'}¨↓buff
              :Else
                  buff3←data[;1]{'<td>',⍺,'</td><td>',(1⊃⍵),'</td><td>',(⍕2⊃⍵),'</td><td>',(3⊃⍵),'</td>'}¨↓buff
              :EndIf
              html,←(↓buff){'<tr',({⍵=3:'' ⋄ ' class="',(⍵⊃'unc' 'fullyC'),'overed"' ⋄ }0 100⍳2⊃⍺),'>',⍵,'</tr>'}¨buff3
          :EndIf
          html,←⊂'</tbody>'
          html,←⊂'</table>'
          html,←⊂'</div>'
          html,←AddJavaScript buff
          :If verbose
              html,←⊂'<h2>Listings</h2>'
              html,←CreateListingForFnsAndOpr data
          :EndIf
      :EndIf
      html,←⊂'<div id="footer">'
      html,←⊂'<hr>'
      html,←⊂'<p>Created by "CodeCoverage" version ',(Version),'</p>'
      html,←⊂'</div>'
      html,←⊂''
      html,←⊂'</body>'
      html,←⊂'</html>'
      filename←(⊃,/2↑⎕NPARTS filename),'.html'
      (⊂html)⎕NPUT filename 1
    ∇

    ∇ html←AddJavaScript data
      html←''
      →(0=≢data)/0
      html,←⊂'<script>'
      html,←⊂'$(document).ready(function() {'
      html,←⊂'    var oTable;'
      html,←⊂'    oTable = $("#percent").DataTable( {'
      html,←⊂'        paging:   false,'
      html,←⊂'        ordering: true,'
      html,←⊂'        info:     true,'
      html,←⊂'        fixedHeader: true,'
⍝     html,←⊂'        order: [2,"desc"],'
      html,←⊂'        order: [2,"asc"],'
      html,←⊂'        dom: "Bft",'
      html,←⊂'        drawCallback: function( settings ) {'
      html,←⊂'             var api = this.api();'
      html,←⊂'             $(''.header[id^="listing_"]'').next().addBack().css("display","none");'  ⍝ hide all lines
      html,←⊂'             api.rows( {page:"current"} ).data().each(function(data){'
      html,←⊂'              id = data[0];'
      html,←⊂'              id = id.match(/"(\#.*?)"/);'
      html,←⊂'              if (id){$(id[1]).next().addBack().css("display","block");}'  ⍝ show header and following code
      html,←⊂'             })'
      html,←⊂'        },      '
      html,←⊂'        buttons: ['
      html,←AddJavaScriptButton('Partly covered' '50%'(+/~data[;2]∊0 100)'^(?!(0%|100%)).*')
      html,←AddJavaScriptButton('Uncovered' '0%'(+/data[;2]=0)'^0%')
      html,←AddJavaScriptButton('Fully covered' '100%'(+/data[;2]=100)'100%')
      html,←AddJavaScriptButton('All' 'all'(≢data)'.')
      html,←⊂'    ],'
      html,←⊂' '
      html,←⊂'        columnDefs: ['
      html,←⊂'            {className: "align-right", targets: [2,3]'
      html,←⊂'            },'
      html,←⊂'            {'
      html,←⊂'                render: function ( data, type, row, meta ) {'
      html,←⊂'                            return data+"%" ;        '
      html,←⊂'                        },'
      html,←⊂'                targets: 2'
      html,←⊂'            }'
      html,←⊂'        ]             '
      html,←⊂'    } );'
      html,←⊂'    oTable.button(0).trigger();'
      html,←⊂''
      html,←⊂'} );    '
      html,←⊂'</script>'
    ∇

    ∇ html←AddJavaScriptButton(caption percent noOf search)
      html←''
      html,←⊂'        {'
      html,←⊂'            text: "',caption,' (',(⍕noOf),')",'
      html,←⊂'            titleAttr: "',percent,'",'
      html,←⊂'            className: "active",'
      html,←⊂'            action: function ( e, dt, node, config ) {'
      html,←⊂'                var text = this.text();'
      html,←⊂'                var search = "',search,'";'
      html,←⊂'                oTable.column(2)'
      html,←⊂'                    .search(search,true,false,false)'
      html,←⊂'                    .draw();'
      html,←⊂'                $(".dt-buttons button").removeClass("active");'
      html,←⊂'                this.active( true );'
      html,←⊂'            }'
      html,←⊂'        },'
    ∇

    ∇ {(details watch)}←ProcessData filename;tno;watched;data;b;details;where;wi;dcfFilename;ignore
     ⍝ Takes the name of a component file created by calling `Start`, `Stop` and `Finalise`.\\
     ⍝ The components are read, aggregated and massaged and finally stored in the tenth component,
     ⍝ but the aggregated data is also returned as a shy result along with the watched data.
      :Access Public Shared
      dcfFilename←(⊃,/2↑⎕NPARTS filename),'.profile'
      'File not found'⎕SIGNAL 11/⍨0=⎕NEXISTS dcfFilename
      tno←dcfFilename ⎕FSTIE 0
      watched←⎕FREAD tno,2
      details←watch←⍬
      :If 0<≢∊data←tno{⎕FREAD ⍺,⍵}¨9↓⍳-/⌽2↑⎕FSIZE tno
          watch←⎕FREAD tno 2
          ignore←⎕FREAD tno 3
          data←⊃⍪/data
          data[;2]←(data[;2]∊¨data[;4])/¨data[;2]
          details←data[;1]{(⊃⍺)(∪⊃,/⍵)}⌸data[;2]
          where←data[;1]⍳details[;1]
          details,←data[where;3 4]
          details(RemoveToBeIgnored)←ignore
          b←details[;3]≠100
          :If ∨/b
              (b/details[;3])←100⌊⌊0.5+100×÷/≢¨b⌿details[;2 4]         ⍝ Recalculate percentage
          :EndIf
          details ⎕FREPLACE tno 10
      :EndIf
      ⎕FUNTIE tno
    ∇

    ∇ r←Finalise dummy;names;details;i;name;row;linesCovered;body;lines;bool;regExPattern;filename;tno;d;buff;crF;crX;crT;crN;fileM;bodyC;t∆
    ⍝ Call this when all the code you want to check on has been executed`.\\
    ⍝ It examines all functions and operators that are only partially covered, and saves the lines that
    ⍝ were executed as well as the lines that could have been executed.\\
    ⍝ For the latter, a number of lines are ignored, such as empty lines, comment lines and all lines
    ⍝ that contain meaningless code (in terms of being executed), such as all `:End*` lines etc.\\
    ⍝ Note that the collected data is appended to the DCF file associated with the instance. Therefore
    ⍝ you can move the DCF file to another platform and re-run the code under the supervision of `CodeCoverage`
    ⍝ again, for example.
      :Access Public Instance
      r←⍬
      0 0⍴{Stop ⍵}⍣(~⊃∆STOPPED)⊣⍬
      _data←_data[;1]{(⊃⍺)(∪⊃,/⍵)}⌸_data[;2]
      names←CollectDataForCoverageReport _watch
      details←0 4⍴⍬
      regExPattern←'^ *:else$' '^ *:section$'                       ⍝ Lines that contain just these patterns...
      regExPattern,←'^ *:access ' '^ *:field ' '^ *:attribute'      ⍝ ... or these are to be ignored.
      regExPattern,←⊂'^ *:end[a-zA-Z]*$'                            ⍝ All sorts of :End* statements are not of interest either
      regExPattern,←⊂'^ *:implements'
      regExPattern,←⊂'^ *:signature'
      regExPattern,←⊂'^ *:section'
      filename←(⊃,/2↑⎕NPARTS _filename),'.profile'
      crF←(∊2↑⎕NPARTS filename),'.cr'                               ⍝ this file has the CRs of everything we watched
      :If crX←⎕NEXISTS crF
          crT←crF ⎕FTIE 0
          crN←⎕FREAD crT,1                                          ⍝ the list of names for which we have CRs in component 1+index
      :Else
          crT←crF ⎕FCREATE 0
          (1 3⍴0 ¯1 0)⎕FSTAC crT                                    ⍝ Everybody everything; important for non-Windows platforms
          crN←⍬
          ⍬ ⎕FAPPEND crT
      :EndIf
     
      :For i :In ⍳≢names
          name←i⊃names
          :If (≢_data)≥row←_data[;1]⍳⊂name
              linesCovered←2⊃_data[row;]
          :Else
              linesCovered←⍬
          :EndIf
     
          :If {~3 4∊⍨10×⍵-⌊⍵}⎕NC⊆name                               ⍝ Ignore derived functions and derived operators
          :AndIf 2≠|≡buff←180⌶name                                  ⍝ For weird staff (like function operands of an operator) we need to check
              :If 0=≢body←{⍵↓⍨-+/∧\' '=⌽⍵}¨↓buff                    ⍝ True for localized dfns
            ⍝ ---------- TODO
            ⍝     ∘∘∘                                               ⍝TODO⍝ We cannot get the body of that dfn with ⎕CR or 180⌶, so we need to take other measures
            ⍝ ----------
              :EndIf
              :If crX
                  :If (⊂name)∊crN
                      :If ~body CompareCR bodyC←⎕FREAD crT,1+crN⍳⊂name
                          ⎕←'Current definition of function "',name,'" does not match the one captured earlier - do not trust the results' ⍝ ⎕SIGNAL?!
                      :EndIf
                  :Else
                      ⎕←'Found new function "',name,'" that was not captured in previous runs - do not trust the results!'
                  :EndIf
              :Else
                  crN,←⊂name
                  body ⎕FAPPEND crT
              :EndIf
              body←'''[^'']*'''⎕R''⍠('Greedy' 0)⊣body               ⍝ Remove text
              body←'⍝.*$'⎕R''⍠('Greedy' 0)⊣body                     ⍝ Remove comments
              lines←¯1+⍳≢body
              :If '}'=⊃{⍵↓⍨+/∧\' '=⍵}⊃¯1↑body                       ⍝ Is it possibly a dfn? (⎕NC does only work on stuff that's not part of a class!)
              :AndIf ∨/(({⍵↑⍨1+-{⍵⍳'.'}⌽⍵}name),'←{')⍷1⊃body        ⍝ First line carries <name>←{   - then it must be a dfn
              :AndIf (,'}')≡¯1↑' '~⍨⊃¯1↑body
                  (body lines)←(0=≢{⍵↓⍨⍵⍳'{'}⊃body)↓¨body lines     ⍝ Drop first line if it is nothing but <name>←{
                  (body lines)←(-(,'}')≡' '~⍨⊃¯1↑body)↓¨body lines  ⍝ Drop last line if it is nothing but a closing "`}`
              :Else
                  (body lines)←1↓¨body lines                        ⍝ Always drop first line in case of a tfn
                  bool←regExPattern∘{0=≢⍺ ⎕S 0⍠('IC' 1)('Greedy' 0)⊣⍵}¨body
                  bool∧←'}'≠⊃∘{⍵↓⍨+/∧\' '=⍵}¨body                   ⍝ Get rid of closing lines of local dfns - otherwise they will be reported
                  (body lines)←bool∘/¨body lines
              :EndIf
              (body lines)←(0<≢¨body~¨' ')∘/¨body lines             ⍝ Remove empty lines
              details⍪←name linesCovered(100-⌊0.5+100×(≢lines~linesCovered)÷≢lines)lines
          :EndIf
     
      :EndFor
     
      details←('.'≠⊃¨¯1↑¨details[;1])⌿details
      :If ~crX
          crN ⎕FREPLACE crT,1
      :EndIf
      ⎕FUNTIE crT
      :If ⎕NEXISTS filename
          tno←filename ⎕FSTIE 0
          (∪watch,⎕FREAD tno 2)⎕FREPLACE tno 2
          (∪ignore,⎕FREAD tno 3)⎕FREPLACE tno 3
          (({0=≢d←⎕FREAD tno 4:0 3⍴'' ⋄ d}⍬)⍪CollectInformation ⍬)⎕FREPLACE tno 4 ⍝ Old versions might still carry an empty forth component
          details ⎕FAPPEND tno
          ⎕FUNTIE tno
      :Else
          (watch ignore details)CreateFile filename
      :EndIf
      r←filename
      ⍝Done
    ∇

    ∇ {r}←{y}CreateFile filename;tno;d;watch;ignore;details
      :Access public Shared
      y←⊆{0<⎕NC ⍵:⍎⍵ ⋄ ''}'y'
      (watch ignore details)←3↑y,(≢y)↓'' '' ''
      r←0
      3 ⎕MKDIR 1⊃⎕NPARTS filename
      tno←filename ⎕FCREATE 0
      (1 3⍴0 ¯1 0)⎕FSTAC tno                                    ⍝ Everybody everything; important for non-Windows platforms
      d←''
      d,←⊂'Documentation regarding the contents of this file'
      d,←⊂(⍴1⊃d)⍴'-'
      d,←⊂'* The first component contains this documentation'
      d,←⊂'* The second one contains what has been watched; this will eventually be used to'
      d,←⊂'  compile the caption for the coverage report.'
      d,←⊂'* The third component holds the names of functions and operators to be ignored.'
      d,←⊂'* The fourth component holds a matrix with as many rows as test runs have been performed:'
      d,←⊂'  [;1] Timestamp ("YYYY-MM-DD hh:mm:ss")'
      d,←⊂'  [;2] The result of the "APLVersion" property + info about the edition'
      d,←⊂'  [;3] ⎕WA in KB'
      d,←⊂'* Components five to nine are reserved'
      d,←⊂'* The tenth one is originally empty. when "ProcessData" or "ProcessDataAndCreateReport"'
      d,←⊂'  is called the resulting data is written to this component.'
      d,←⊂'After the tenth one all components carry a matrix with n rows and 4 columns. n is'
      d,←⊂'determined by the number of fns/oprs involved. The columns:'
      d,←⊂'[;1] The name of the function or operator'
      d,←⊂'[;2] Either empty or a vector of line numbers there were *not* executed.'
      d,←⊂'     Empty in case none or all lines were executed.'
      d,←⊂'[;3] Coverage percentage.'
      d,←⊂'[;4] Total number of lines that can be expected to be tested.'
      d ⎕FAPPEND tno
      watch ⎕FAPPEND tno
      ignore ⎕FAPPEND tno
      (CollectInformation ⍬)⎕FAPPEND tno
      tno{⍵ ⎕FAPPEND ⍺}¨(9-¯1+2⊃⎕FSIZE tno)⍴⊂''                 ⍝ Fill up to the tenth component
      details ⎕FAPPEND tno
      ⎕FUNTIE tno
    ∇

    ∇ {r}←Start dummy
      ⍝ Execute `⎕PROFILE'start' 'coverage'`
      :Access Public Instance
      r←⍬
      ⎕PROFILE'clear'
      ⎕PROFILE'start' 'coverage'
      ∆STOPPED←0
    ∇

    ∇ {r}←Stop dummy;buff
    ⍝ Stores all the data collected since `Start` was invoked, and then executes `⎕PROFILE'clear'`
      :Access Public Instance
      r←⍬
      buff←(⎕PROFILE'data')[;1 2]
      ⎕PROFILE'clear'
      buff←(buff[;2]≢¨⊂⍬)⌿buff                                 ⍝ Fns as such are not of any interest, only lines
      _data⍪←(⊃∨/watch{((1+≢¨⍺)↑¨¨⊂⍵)∊¨⊂¨⍺,¨'.'}buff[;1])⌿buff ⍝ Drop everthing that's not watched
      ∆STOPPED←1
    ∇

⍝ ------------------------ Private stuff

    ∇ html←CreateListingForFnsAndOpr partlyCovered;name;lines;body;width;html2;all;testable;where;buff;i;links;percent;cr
      cr←⎕NS''
      html←''
      links←'<a class="float-right no-print no-underline top-links" href="#top" title="Go to the top of the document">&#8607;</a>'
      links,←'<a  class="float-right no-print no-underline top-links" href="#partly-covered" title="Go to the beginning of ''Partly-covered''">↑</a>'
      cr.filename←(⊃,/2↑⎕NPARTS filename),'.cr'             ⍝ this file has the CRs of everything we watched
      :If ⎕NEXISTS cr.filename
          cr.tno←cr.filename ⎕FTIE 0
          cr.names←⎕FREAD cr.tno,1
          ⎕←'Tied ',cr.filename,' for listings'
      :Else
          ⎕←'Did not find file "',cr.filename,'" with CRs collected by fn "Finalise" - will try to work without it'
          cr.tno←0
      :EndIf
      :For i :In ⍳≢partlyCovered
          (name lines percent testable)←partlyCovered[i;1 2 3 4]
          :If (cr.tno=0)∨~(⊂name)∊cr.names
              body←{⍵↓⍨-+/∧\' '=⌽⍵}¨↓180⌶name
          :Else
              :If cr.tno∊⎕FNUMS
                  body←⎕FREAD cr.tno,1+cr.names⍳⊂name
              :Else
                  body←⍬
              :EndIf
          :EndIf
          :If 0<≢body
              body←ExchangeHtmlSpecialChars body
              (1⊃body)←{⍵↑⍨¯1+⌊/⍵⍳'⍝;'}1⊃body
              width←≢⍕≢body
              html2←((⊂(width-1)⍴' '),(width+4){⍺↑' [',(⍕⍵),']'}¨¯1↓⍳≢body),¨body,¨⊂'</code>'
              :If 0<≢lines
                  (⊃¨html2[lines+1])←'→'   ⍝TODO⍝ Check!
              :EndIf
              buff←(≢body)⍴⊂'<code>'
              buff[lines+1]←⊂'<code class="emphasize">'
              html2←buff,¨html2
              (1⊃html2)←'<div class="code-block">',1⊃html2
              html2,←⊂'</div>'
              html2←(⊂'<code class="header" id="listing_',(⍕i),'">',name,(' &mdash; ',(⍕percent),'%'),links,'</code>'),html2
              html,←html2
          :Else
              html2←⊂'<div class="code-block missing">Could not get canonical representation.</div>'
              html2←(⊂'<code class="header" id="listing_',(⍕i),'">',name,(' &mdash; ',(⍕percent),'%'),links,'</code>'),html2
              html,←html2
          :EndIf
      :EndFor
      ⎕FUNTIE cr.tno
      ⎕DL 0.1
    ∇

      Shorten←{
    ⍝ '1-3,5,6-9,11' ← Shorten 1 2 3 5 6 7 8 9 11
          ⍺←''
          0=≢⍵:¯1↓⍺
          n←+/∧\⍵=(⊃⍵)+¯1+⍳≢⍵
          1=n:(⍺,(⍕⊃⍵),',')∇ 1↓⍵
          (⍺,({(⍕⊃⍵),'-',(⍕¯1↑⍵)}n↑⍵),',')∇ n↓⍵
      }

    ∇ r←GetScreenCss
      r←''
      r,←⊂'@media screen{'
      r,←⊂'    html {background-color: #FFFFF0;}'
      r,←⊂'body {'
      r,←⊂'    font-size: 16px;'
      r,←⊂'    font-family : Verdana, "Bitstream Vera Sans", "DejaVu Sans", Tahoma, Geneva, Arial, Sans-serif;'
      r,←⊂'    margin: 1em;'
      r,←⊂'}'
      r,←⊂'th, td {padding: 5px 10px;}'
      r,←⊂'th {text-align: left;}'
      r,←⊂'h1, h2, h3, h4, h5, h6 {color: #424242;}'
      r,←⊂'h1 {font-size: 22px;}'
      r,←⊂'h2 {font-size: 18px; margin-top: 2em; margin-bottom:0.3em;}'
      r,←⊂'tbody tr:nth-child(even) {background-color: #F0F0F0;}'
      r,←⊂'tbody tr:nth-child(odd) {background-color: #FAFAFA;}'
      r,←⊂'th {background-color: #E6E6E6;color: #424242;}'
      r,←⊂'table {border: silver 1px solid; font-size: 14px;font-family: APLFont, monospace;}'
      r,←⊂'code , code a {font-size: 14px; font-family: APLFont, monospace;}'
      r,←⊂'code.header {'
      r,←⊂'    font-size: 16px; '
      r,←⊂'    font-family: APLFont, monospace; '
      r,←⊂'    margin: 1.5em 0.5em 0 0.5em; '
      r,←⊂'    padding:0;'
      r,←⊂'    display: block;'
      r,←⊂'}'
      r,←⊂'div.code-block {'
      r,←⊂'    border: 1px silver dashed;'
      r,←⊂'    background-color: #F2F2F2;'
      r,←⊂'    display: block;'
      r,←⊂'    margin: 0.5em 0.5em 0.5em 0.5em;'
      r,←⊂'    padding: 0.5em;'
      r,←⊂'}'
      r,←⊂'div.code-block.missing {'
      r,←⊂'    background-color: #fa605254;'
      r,←⊂'}'
      r,←⊂'div.code-block code {display: block; white-space: pre-wrap; margin:0; padding:0; word-wrap: break-word;}'
      r,←⊂'.emphasize { font-weight: 800;}'
      r,←⊂'ul li, ol li {margin: 0.7em 0.2em;}'
      r,←⊂'.float-right {float:right;}'
      r,←⊂'.no-underline {    text-decoration :none;}'
      r,←⊂'.top-links {font-size:20px; padding-left: 0.6em;}'
      r,←⊂'.align-right {text-align: right;}'
      r,←⊂'#footer hr {margin-top:1.5em;}'
      r,←⊂'#footer p {margin-top:5px; padding-top:0; font-size: 9px;}'
      r,←⊂'@font-face {'
      r,←⊂'        font-family: "APLFont";'
      r,←⊂'    src:'
      r,←⊂'        local("APL385 Unicode"),'
      r,←⊂'        url("https://misc.aplteam.com/apl385.ttf") format("truetype");'
      r,←⊂'}'
      r,←⊂'.info {border: 1px silver dashed; background-color: #F2F2F2;margin: 0.5em; padding: 0.5em;}'
      r,←⊂'}'
    ∇

    ∇ r←GetPrintCss
      r←''
      r,←⊂'@media print{@page {size: portrait}'
      r,←⊂'@page {'
      r,←⊂'    margin: 1cm 1cm 1cm 1.75cm;'
      r,←⊂'    @bottom-right {'
      r,←⊂'        content: counter(page) " / " counter(pages);'
      r,←⊂'  }'
      r,←⊂'}'
      r,←⊂'body {'
      r,←⊂'    font: 12pt "Times New Roman", Times, serif;'
      r,←⊂'    line-height: 1.2;'
      r,←⊂'     /* CSS3 filter, at the moment Webkit only. Prefix it for future implementations */'
      r,←⊂'    -webkit-filter: grayscale(100%);'
      r,←⊂'    filter: grayscale(100%); /* future-proof */'
      r,←⊂'}'
      r,←⊂'h1 {font-size: 18pt;}'
      r,←⊂'h2 {font-size: 16pt; margin-top: 10pt; margin-bottom: 3pt;}'
      r,←⊂'th, td {padding: 2pt 3pt;}'
      r,←⊂'th {text-align: left;background-color: #DBDBDB;}'
      r,←⊂'tbody tr:nth-child(odd) {background-color: #EDEDED;}'
      r,←⊂'table {'
      r,←⊂'    color-adjust: exact !important;'
      r,←⊂'    -webkit-print-color-adjust: exact !important;'
      r,←⊂'    print-color-adjust: exact !important;'
      r,←⊂'    font-size: 8pt;'
      r,←⊂'    font-family: APLFont, monospace;'
      r,←⊂'}'
      r,←⊂'div.keep-together {break-inside: avoid; break-before:auto;}'
      r,←⊂'table {border: silver 1pt solid;}'
      r,←⊂'code , code a {font-size: 8pt; font-family: APLFont, monospace;}'
      r,←⊂'code.header {'
      r,←⊂'    font-size: 8pt;'
      r,←⊂'    font-family: APLFont, monospace;'
      r,←⊂'    margin: 7pt 3pt 0 10pt;'
      r,←⊂'    padding:0;'
      r,←⊂'    display: block;'
      r,←⊂'}'
      r,←⊂'div.code-block {'
      r,←⊂'    border: 1pt silver dashed;'
      r,←⊂'    background-color: #F2F2F2;'
      r,←⊂'    display: block;'
      r,←⊂'    margin: 4pt 4pt 4pt 4pt;'
      r,←⊂'    padding: 4pt;'
      r,←⊂'}'
      r,←⊂'div.code-block code {display: block; white-space: pre-wrap; margin:0; padding:0; word-wrap: break-word;}'
      r,←⊂'.emphasize { font-weight: 800;}'
      r,←⊂'a {text-decoration: none;color: black;}'
      r,←⊂'ul li, ol li {margin: 8pt 3pt;}'
      r,←⊂'.no-print {display:none;}'
      r,←⊂'.align-right {text-align: right;}'
      r,←⊂'#footer hr {margin-top:1.5em;}'
      r,←⊂'#footer p {margin-top:5pt; padding-top:0; font-size: 6pt;}'
      r,←⊂'@font-face {'
      r,←⊂'        font-family: "APLFont";'
      r,←⊂'    src:'
      r,←⊂'        local("APL385 Unicode"),'
      r,←⊂'        url("https://misc.aplteam.com/apl385.ttf") format("truetype");'
      r,←⊂'}'
      r,←⊂'.info {border: 1px silver dashed; background-color: #F2F2F2;margin: 8px; padding: 8px;}'
      r,←⊂'}'
    ∇

    ∇ names←CollectDataForCoverageReport watch;this;ref;list;isScripted;this2;ref2
    ⍝ Determins all objects to be observed together with the number of lines.
      names←''
      :For this :In ,⊆watch
          ref←⍎this
          :If IsScripted ref
              names,←(⊂this,'.'),¨NamesInScript ref
          :Else
              names,←(⊂this,'.'),¨' '~¨⍨↓ref.⎕NL 3 4
              :If 0<≢list←ref.⎕NL 9
                  list←' '~¨⍨↓list
                  isScripted←IsScripted¨ref⍎¨list
                  :For this2 :In isScripted/list
                      ref2←ref⍎this2
                      :If (⍕ref2)≡this,'.',this2                            ⍝ Ignore references
                          names,←(⊂this,'.',this2,'.'),¨NamesInScript ref2
                      :EndIf
                  :EndFor
                  :If 0<≢list←(~isScripted)/list
                  :AndIf 0<≢list←({⍵≡⍕⍎⍵}¨(⊂this,'.'),¨list)/list           ⍝ Ignore references
                      names,←⊃,/CollectDataForCoverageReport¨(⊂this,'.'),¨list
                  :EndIf
              :EndIf
          :EndIf
      :EndFor
    ∇

    ∇ r←NamesInScript ref;body;options;b;tfns;dfns;b2;bodies
      :Access Public Shared
    ⍝ Takes a ref pointing to a class or interface script and returns the names of all functions and operators
    ⍝ within that script.\\
    ⍝ Has two limitations:
    ⍝ * Cannot handle nested classes and nested namespaces.
    ⍝ * May well mistake a variable name for the name of a dfn.\\
      r←''
      body←⎕SRC ref
      body←'''[^'']*'''⎕R''⊣body                                     ⍝ Get rid of everything between quotes
      body←'⍝.*$'⎕R''⊣body                                           ⍝ Get rid of comments
      options←('IC' 1)('Greedy' 0)('DotAll' 1)('Mode' 'D')
      r,←options GeterAndSetterNames body                            ⍝ Extract the names of all getters and setters (if any)
      body←':Property .*:EndProperty'⎕R''⍠options⊣body               ⍝ Remove Properties (because they carry `∇`!)
      body←¯1↓1↓(~body∧.=¨' ')/body                                  ⍝ Remove first, last and all empty lines
      body←'^ {5,}∇.*$'⎕R''⊣body                                     ⍝ Remove recursive ∇ calls that stand on their own
      b←'∇'∊¨body                                                    ⍝ Which lines carry a ∇?
      ((b\{{1=≢⍵:0 ⋄ '∇'≠⊃⍵}⍵~' '}¨b/body)/body)←' '                 ⍝ Remove all other recursive ∇ calls
      body↓¨⍨←{+/∧\' '=⍵}¨body                                       ⍝ Drop all leading spaces
      b←'∇'=⊃¨body                                                   ⍝ All lines that start with a nabla
      tfns←b/body                                                    ⍝ Trad fns headers
      tfns←1↓¨tfns                                                   ⍝ Remove the nablas
      tfns←((≢tfns)⍴1 0)/tfns                                        ⍝ Remove every second line: those are the closing ones
      tfns←{'←'∊⍵:⍵↓⍨⍵⍳'←' ⋄ ⍵}¨tfns                                 ⍝ Remove all explicit results
      tfns←{'{'∊⍵:⍵↓⍨⍵⍳'}' ⋄ ⍵}¨tfns                                 ⍝ Remove optional left argument
      tfns←{⍵↓⍨+/∧\' '=⍵}¨tfns                                       ⍝ Remove all leading spaces
      tfns←{⍵/⍨~'  '⍷⍵}¨tfns                                         ⍝ Remove all multiple spaces
      tfns←{⍵↓⍨{-+/∧\' '=⍵}⌽⍵}¨tfns                                  ⍝ Remove all trailing spaces
      :If ∨/b←'('=⊃¨tfns                                             ⍝ These must be operators
          (b/tfns)←{{⍵↑⍨¯1+⍵⍳')'}⍵↓⍨⍵⍳' '}¨b/tfns                    ⍝ Extract the operator names
      :EndIf
      tfns←'\([^)]+\)'⎕R' foo'⊣tfns                                  ⍝ Replace anything betwen () by ` foo` = impersonate a simple ⍵
      :If 0<≢tfns←{2=' '+.=⍵:⍵↓⍨⍵⍳' ' ⋄ ⍵}¨tfns                      ⍝ Remove left arguments
          r,←{⍵↑⍨¯1+⌊/⍵⍳' ;'}¨tfns                                   ⍝ Name of all trad fns
      :EndIf
      :If 0<≢bodies←'∇[^∇]*∇'⎕S{⍵.Match}⍠options⊣body                ⍝ Every trad fn must be investigated for any local dfns.
      :AndIf 0<≢bodies←{(⎕UCS 10)~¨⍨(~(⎕UCS 13 10)⍷⍵)⊆⍵}¨bodies      ⍝ Split them one-by-one
          r,←{0=≢⍵:⍵ ⋄ ⊃,/⍵}EstablishDfns¨bodies                     ⍝ All dfns defined within tradfns
      :EndIf
      body←'∇[^∇]*∇'⎕R''⍠options⊣body                                ⍝ Wipe out all trad fns
      body←(0<≢¨body~¨' ')/body                                      ⍝ No empty lines
      ⍝ --- Next two lines are future stuff
      ⍝ dfns←EstablishDfns body                                      ⍝ Extract the dfns (and dops of course)
      ⍝ r,←∪dfns                                                     ⍝ Those might well be variable assignment, therefore ∪!
    ∇

    IsScripted←{16::0 ⋄ 1⊣⎕SRC ⍵}

      EstablishDfns←{
      ⍝ In case ⍺ is 1 just the names of all dfns (dops) found in ⍵ are returned.
      ⍝ In case ⍺ is 0 only names that are localized are returned.
          ⍺←1
          body←⍵
          dfns←(∨/¨'←{'∘⍷¨body)/body                                 ⍝ Only lines that carry ←{ will survive
          0=≢dfns:''
          dfns←(0=≢¨1↓¨⊃¨{'\}(.*$)'⎕S{⍵.Match}⊣⍵}¨dfns)/dfns         ⍝ Get rid of one-line unnamed dfns
          0=≢dfns:''
          dfns←{⍵↑⍨¯1+⍵⍳'←'}¨dfns                                    ⍝ Assignments survive
          dfns←(¯1≠⊃∘⎕NC¨dfns)/dfns                                  ⍝ Get rid of what is an invalid name (those are variable assignments)
          0=≢dfns:''
          dfns~¨←' '                                                 ⍝ Remove all spaces
          ⍺:dfns
          ∘∘∘ ⍝TODO⍝
      }

    ∇ r←options GeterAndSetterNames body;bool
      r←''
      body←1↓⊃,/(⎕UCS 10),¨body
      :If ∨/bool←':property'⍷⎕C body
          r,←⊃,/body∘{'set_' 'get_',¨⊂(1+≢':propert')↓{⍵↑⍨¯1+⍵⍳⎕UCS 10}⍵↓⍺}¨{⍵/⍳≢⍵}bool
      :EndIf
    ∇

    ∇ data←data RemoveToBeIgnored ignore;bool
      ⍝ `ignore` is a nested vector with nanes. In case such a name identifies any APL object it is removed.\\
      ⍝ However, if an ordinary namespace is part of `ignore` then it won't appear in `data`.
      ⍝ Therefore we identify container names in a second step and remove everything that belongs to such a container.
      ⍝ That means it works recursively.
      :If 0<≢ignore
      :AndIf 0<≢data←(~data[;1]∊ignore)⌿data
          bool←9=⊃∘⎕NC¨ignore
          data←(⊃∧/data∘{⍵∘≢¨(≢⍵)↑¨⍺[;1]}¨((bool/ignore),¨'.'))⌿data
      :EndIf
    ∇

    ∇ r←FormatDateTime ts
      r←⊃'YYYY-MM-DD hh:mm:ss'(1200⌶)¯1 1 ⎕DT⊂ts
    ∇

    ∇ r←CollectInformation dummy;version;ts
    ⍝ Collects information about the current test run.
      ts←FormatDateTime ⎕TS
      version←⊃{⍺,' ⋄ ',⍵}/# ⎕WG'APLVersion'
      version,←' ⋄ ','Classic' 'Unicode'⊃⍨1+80=⎕DR' '
      r←1 3⍴ts version(' '~⍨,'K0G⊂ZZZ.ZZZ.ZZZ.ZZZ.ZZ9⊃'⎕FMT⌊⎕WA÷1024×1024) ⍝ MBs
    ∇
    ∇ txt←ExchangeHtmlSpecialChars txt
    ⍝ < => &lt; ⋄ > => &gt; ⋄ & => &amp;
      txt←(,¨'&<>')⎕R'\&amp;' '\&lt;' '\&gt;'⊣txt
    ∇

    ∇ z←a CompareCR b;args;i;m;l
      ⍝ compare two CRs taking into account that some symbols are replaced with ⎕Uxxxx when loaded into classic
      ⍝ z=1: match, 0: did not match
      ⍝--> this means that the final run which creates the report must be run on a Unicode interpreter, otherwise
      ⍝    it will crash with errors because it can't deal with these characters...
      :If {0::1 ⋄ 0⊣⎕UCS ⍵}8838  ⍝ do not even attempt to execute this on Classic!
          z←1
      :ElseIf a≠⍥≢b   ⍝ no of lines must match
          z←0
      :Else
          args←{1=≡⍵:↓⍵ ⋄ ⍵}¨a b
          :For i :In ⍳2
              :For m :In ('(⎕u\d*)'⎕S 2⍠'IC' 1)i⊃args
                  :If m≢0
                      l←(⎕IO+m)⊃i⊃args
                      l←('⎕u(\d*.)'⎕R{{(⎕UCS dec ¯1↓⍵),(' '≢⍥,¯1↑⍵)/¯1↑⍵}2↓⍵.Match}⍠'IC' 1)l
                      ((⎕IO+m)⊃i⊃args)←l
                  :EndIf
              :EndFor
          :EndFor
          z←≡/args
      :EndIf
    ∇

      ⍝ from dfns
      dec←{⎕IO ⎕ML←0 1                                ⍝ Decimal from hexadecimal
          ⍺←0                                         ⍝ unsigned by default.
          1<⍴⍴⍵:⍺∘∇⍤1⊢⍵                               ⍝ vector-wise:
          0=≢⍵:0                                      ⍝ dec'' → 0.
          1≠≡,⍵:⍺ ∇¨⍵                                 ⍝ simple-array-wise:
          ws←∊∘(⎕UCS 9 10 13 32 160)                  ⍝ white-space?
          ws⊃⍵:⍺ ∇ 1↓⍵                                ⍝ ignoring leading and
          ws⊃⌽⍵:⍺ ∇ ¯1↓⍵                              ⍝ ... trailing blanks.
          ∨/ws ⍵:⍺ ∇¨(1+ws ⍵)⊆⍵                       ⍝ white-space-separated:
          v←16|'0123456789abcdef0123456789ABCDEF'⍳⍵   ⍝ hex digits.
          11::'Too big'⎕SIGNAL 11                     ⍝ number too big.
          (16⊥v)-⍺×(8≤⊃v)×16*≢v                       ⍝ (signed) decimal number.
      }


    Assert←{⍺←⊢ ⋄ 0∊⍵:⍺ ⎕SIGNAL 998 ⋄ shy←0}

    ∇ r←IsFile filename
      r←0
      :Trap 22
          r←2=1 ⎕NINFO filename
      :EndTrap
    ∇

:EndClass
